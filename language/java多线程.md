# Java多线程
## Java内存模型
**java内存模型是一个语言级别的内存模型，决定了一个线程对共享变量的写入何时对另一个线程可见。它确保在不同的编译器和处理器平台上，通过禁止特定类型的编译重排序和处理器重排序，为程序员提供一个内存可见性保证**。

需要以下几个方面进行描述内存模型：

1. 什么是可见性？为什么存在内存可见性不一致？
1. 重排序。什么是重排序？为什么要重排序？重排序引起的原因是什么？为什么重排序会引起不可见？
2. 内存可见性保证。JMM如何保证内存可见性？
3. 为了实现可见性保证，java底层如何实现？
4. Java提供了那些工具保证多线程环境下正确同步并保证可见性，这些工具底层是怎么实现的。

### 1. 什么是可见性
**可见性：一个线程修改了一个共享变量时，另一个线程能够读到这个修改的变量值**。

为什么一个线程对共享变量的修改，可能存在另个线程读不到该共享变量的修改值呢？
这个就涉及到CPU处理器的缓存问题， CPU是高速设备，与内存读取之间存在速度差问题。为了提高CPU的处理性能，在CPU和内存之间往往会加入多级缓存，来解决CPU和内存的速度不匹配问题。

因为各个CPU处理器都有自己的缓存和寄存器等，导致处理器都会有主存共享变量的一个副本。CPU对共享变量的修改是直接写到自己的处理器缓存中：

 1. 如果处理器未将缓存中的数据回写到内存，其他处理器则不可见。--这个问题会引起内存系统的重排序。
 2. 如果写入主内存后，没有合理通知其他处理器更新本地缓存变量值，那么也存在不一致问题，即可见性问题。---volicate通过缓存一致性来保证，底层采用处理器的嗅探技术。

### 2. 重排序
除了CPU处理器的缓存读写同步问题会引起不可见问题外，重排序也会引起该问题。在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。 重排序分为三种：

 - **编译器优化的重排序**: 编译器在不改变单线程程序语义的前提下，可以重新安排语句执行顺序。
 - **指令级并行的重排序**: 现代处理器采用执行并行技术来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对机器指令的执行顺序（单线程情况下考虑数据依赖性）。
 - **内存系统的重排序**: 由于处理器使用了缓存和读/写缓冲区，使得加载和存储操作看上去可能是在乱序执行。

### 3. 内存可见性保证
Java 5开始使用新的JSR-133内存模型，JSR-133使用happen-before概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happen-before关系。

happen-before关系包括：

 - **程序顺序规则**: 一个线程中的每个操作，happens-before于该线程中的任意后续操作。
 - **监视器锁规则**: 对一个锁的解锁，happens-before于随后对于这个锁的加锁。
 - **volatile变量规则**：对于一个volatile域的写，happens-before于任意后续这个volatile域的读。
 - **传递性规则**: 如果A happens-before B，且B happens-before C, 那么A happens-before C。
 - **start()规则**: 如果线程A执行操作ThreadB.start(), 那么线程A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
 - **join()规则**: 如果线程A执行操作ThreadB.join()并返回成功，那么线程B中任意操作happens-before于线程A从ThreadB.join()操作成功返回。
 
### 4. 底层如何实现
底层实现需要考虑两个问题：

 1. 如何禁止重排序，来保证内存可见性。即在满足happen-before规则时，如何保证线程可见性？
 2. 对不同的线程场景下JMM如何处理，如何保证内存一致性？

第一个问题如何禁止重排序，底层采用的是内存屏障来控制。第二个问题包括三个场景：

 1. **单线程**环境下如何保证一致性？
 2. 多线程环境下**正确同步**情况如何保证？
 3. 多线程环境下**未正确同步**情况下JMM如何保证？

#### 4.1 禁止重排序--内存屏障
为了保证内存可见性保证，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障分为四类：

 - LoadLoad Barriers

    ```
    Load1; LoadLoad;Load2
    ```
    确保Load1数据的装载咸鱼Load2及其所有后续装载指令 

 - StoreStore Barriers
 
    ```
    Store1; StoreStore; Store2
    ```
    确保Store1数据对其他处理器可见(刷新到内存)先于Store2及其所有后续存储指令的存储
 
 - LoadStore Barriers 

    ```
    Load1; LoadStore; Store2
    ``` 
    
    确保Load1数据转载先于Store2及所有后续的存储指令刷新到内存 

 - StoreLoad Barries
 
    ```
    Store1; StoreLoad; Load2
    ```
    确保Store1数据对其他处理器变得可见先于Load2及其所有后续装载指令的装载。**它会是该屏障之前的所有内存访问指令(存储和装载指令)完成之后，才执行该屏障后内存访问指令**。是一个全能型的屏障.

#### 4.2 不同线程场景下的可见性保证
##### 1）单线程---数据依赖性保证
在单线程环境下提供了两个保证：

 1. **数据依赖性保证**: 在单线程环境下如果两个操作之间存在数据依赖性，那么编译器和处理器会遵守数据依赖性规则，不会改变这两个存在数据依赖关系的操作的执行顺序。---由操作系统底层支持。
 2. **as-if-serial语义保证**: 单线程环境下不管编译器和处理器怎么重排序，程序的执行结果不能被改变。实际上为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖性关系的操作做重排序。
 

##### 2）多线程正确同步---顺序一致性内存模型
多线程环境下编译器和处理器不会提供数据依赖性保证，因为可能会改变程序的执行结果。在多线程模型下，处理器内存模型和编程语言的内存模型都会以**顺序一致性内存模型**作为参照，顺序一致性内存模型是一个理论参考模型。

顺序一致性内存模型具有两大特性：

 1. 一个线程的所有操作必须按照程序的顺序来执行。
 2. 不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行并且对所有线程可见。

JMM对**正确同步**的多线程程序的内存一致性做了以下保证：如果程序是**正确同步**，程序执行将具有顺序一致性--即程序的执行结果与该程序顺序一致性内存模型中的执行结果相同。

##### 3）多线程未正确同步---最小安全性保证
未正确同步程序, JMM提供了最小安全性：线程读取到的值要么是之前线程写入的值，要么是默认值，JMM保证线程读操作读取到的值不会无中生有。

### 5. 多线程同步可见性保证工具
Java内部提供了多种线程同步工具，来保证内存可见性：

1. volatile 
2. final
3. 锁



 
 




