# 限流和熔断

在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流

- **缓存**：缓存的目的是提升系统访问速度和增大系统处理容量
- **降级**：降级是当服务出现问题或者影响到核心流程时，需要暂时屏蔽掉，待高峰或者问题解决后再打开
- **限流**：限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理


## 限流
常用的限流算法有两种：**漏桶算法**和**令牌桶算法**

- **漏桶算法**思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。
- **令牌桶算法**的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。



Google开源工具包Guava(java)提供了限流工具类RateLimiter，该类基于**令牌桶算法**实现流量限制。
Guava有两种限流模式：

- 一种为**稳定模式**(SmoothBursty:令牌生成速度恒定)
- 一种为**渐进模式**(SmoothWarmingUp:令牌生成速度缓慢提升直到维持在一个稳定值)

两种模式实现思路类似，主要区别在等待时间的计算上。根据令牌桶算法，桶中的令牌是持续生成存放的，有请求时需要先从桶中拿到令牌才能开始执行，谁来持续生成令牌存放呢？


一种解法是，开启一个**定时任务**，由定时任务持续生成令牌。这样的问题在于会极大的消耗系统资源，如，某接口需要分别对每个用户做访问频率限制，假设系统中存在6W用户，则至多需要开启6W个定时任务来维持每个桶中的令牌数，这样的开销是巨大的。

另一种解法则是**延迟计算**，如上resync函数。该函数会在每次获取令牌之前调用，其实现思路为，若当前时间晚于nextFreeTicketMicros，则计算该段时间内可以生成多少令牌，将生成的令牌加入令牌桶中并更新数据。这样一来，只需要在获取令牌时计算一次即可。


RateLimiter 源码：https://segmentfault.com/a/1190000012875897




