# 事务原理
## 四个特性
- **原子性（Atomicity）**: 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚.
- **一致性（Consistency）**: 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
- **隔离性（Isolation）**: 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
- **持久性（Durability）**: 是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。


### 隔离性
mysql提了四种隔离级别:

- **READ UNCOMMITTED(读取未提交内容)**: 所有事务都可以“看到”未提交事务的执行结果。会出现脏读。
- **READ COMMITTED(读取提交内容)**: 只能看见已经提交事务所做的改变，一个事务从开始到提交之前，所做的任何数据改变都是不可见的。这种级别会出现**不可重复读**, 运行同一个语句两次，看到的结果不同。
- **REPEATABLE READ(可重复读)**: 确保同一个事务的多个实例并发读取数据时，看到同样的数据行。 这个会导致**幻读**，用户读取某一个范围的数据行时，另一个事务又在该范围内插入新行。
- **SERIALIZABLE(可串行化)**: 最高级别，强制事务排序，使之不可能相互冲突，从而解决幻读问题。


## 实现

事务的一致性、持久性、原子性是通过redo log和undo log来实现了.

- **redo log**: 重做日志，恢复提交事务修改的页操作，用来保证事务原子性和持久性。基本上都是顺序写，在数据库运行时不需要对redo log的文件进行读取操作。
- **undo log**: 用来保证事务的一致性， undo用来帮助事务回滚及MVCC功能，是回滚行记录到某个特定版本。undo log 是需要进行随机读写的。

## redo
因为mysql存在缓存，数据的修改插入一般都现在缓存操作，如果服务宕机这些数据会丢失。为了保证数据的**持久性**，先进入到redo文件。在数据库重启的时候进行恢复。

当事务提交是(commit)时，必须先将该事务的所有日志写入重做日志文件进行持久化，待事务的commit操作完成后才算完成。这里重做日志由两部分组成: redo log 和 undo log. 

重做日志由两部分组成：

-  重做日志缓冲(redo log buffer)
-  重做日志文件(redo log file)

在提交前先写写入重做日志缓存，提交是将将日志缓冲写入重做日志文件，InnoDB存储引擎都需要调用一次**fsync**操作才能真正将系统文件缓存的内容写到重做日志文件中。为了提高性能，并非每次提交时都进行一次fsync操作。通过**innodb_flush_log_at_trx_commit**来控制重做日志刷新到磁盘的策略，默认是1即表示事务提交时必须调用一次fsync操作。

二进制日志只在事务提交完成后进行一次写入，而InnoDB存储引擎的重做日志在事务进行中不断地被写入。

重做日志都是以512字节进行存储的，意味着重做日志缓存、重做日志文件都是以块的方式进行保存，称之为重做日志块**(redo log block)**, 每块大小为512字节。

InnoDB存储引擎在启动时不管上次数据库运行时是否正常关闭，都会尝试进行恢复操作。重做日志是幂等的，而二进制日志不是幂等的。


重做日志记录了事务的行为，可以很好地通过其对页进行“重做”操作。

## undo
事务的回滚操作通过undo来实现，在数据库执行修改时，InnoDB存储引擎补单会产生redo，还会产生一定量的undo. 如果用户执行的事务或语句由于某种原因失败了，或者用户执行了ROLLBACK指令，就可以使用这些undo数据回滚到修改之前的样子。


undo不是存放在日志文件中，而是存放在数据库内部的一个特殊段(segment)中，这个段叫做undo段(undo segment)。 undo段位于共享表空间内。

undo是逻辑日志，只是将**数据库逻辑地恢复到原来的样子**，而不是数据库物理地恢复到执行语句或事务之前的样子。因为并发原因，有其他事务对物理内容有做修改。


undo的另一个作用的MVCC，即在InnoDB存储引擎中MVCC的实现通过undo来完成。当用户读取一行记录时，弱该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以实现非锁定读。

undo log的产生会伴随着redo log的产生，这是因为undo log 也需要持久性的保护。

undo log 分为：

- insert undo log
- update undo log


## purge
delete 和update操作可能并不直接删除原来的数据， purge用于最终完成delete和update操作。这样的设计是因为InnoDB存储引擎支持MVCC，所以记录不能在事务提交时立即进行处理。这时其他事务可能正在引用这行，故InnoDB存储引擎需要保存记录之前的版本。

如果该行记录已不被任何其他事务引用，那么就可以进行真正的delete操作。





